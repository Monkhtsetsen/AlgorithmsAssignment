import folium
import webbrowser
import os
import math
from collections import deque
import heapq
import time


class GraphBuilder:
    def __init__(self):
        self.nodes = {}
        self.adjacency_list = {}

    def add_edge(self, node1: int, node2: int, weight: float):
        if node1 not in self.adjacency_list:
            self.adjacency_list[node1] = []
        self.adjacency_list[node1].append((node2, weight))


class SearchAlgorithms:
    def __init__(self, graph_builder):
        self.graph = graph_builder

    def calculate_path_distance(self, path):
        total = 0
        for i in range(len(path) - 1):
            for neighbor, weight in self.graph.adjacency_list.get(path[i], []):
                if neighbor == path[i + 1]:
                    total += weight
                    break
        return total

    def bfs_shortest_path(self, start: int, end: int):
        start_time = time.time()

        if start not in self.graph.adjacency_list or end not in self.graph.adjacency_list:
            return [], float('inf'), {'time': 0}

        visited = set()
        queue = deque([(start, [start])])
        visited.add(start)

        while queue:
            current, path = queue.popleft()

            if current == end:
                time_taken = time.time() - start_time
                distance = self.calculate_path_distance(path)
                return path, distance, {'time': time_taken}

            for neighbor, weight in self.graph.adjacency_list.get(current, []):
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append((neighbor, path + [neighbor]))

        return [], float('inf'), {'time': time.time() - start_time}

    def dfs_all_paths(self, start: int, end: int, max_paths: int = 5):
        start_time = time.time()
        all_paths = []

        def dfs(current, path, visited):
            if len(all_paths) >= max_paths:
                return

            if current == end:
                path_info = {
                    'path': path.copy(),
                    'distance': self.calculate_path_distance(path),
                    'steps': len(path) - 1
                }
                all_paths.append(path_info)
                return

            visited.add(current)

            for neighbor, weight in self.graph.adjacency_list.get(current, []):
                if neighbor not in visited:
                    dfs(neighbor, path + [neighbor], visited.copy())

        dfs(start, [start], set())
        all_paths.sort(key=lambda x: x['distance'])

        return all_paths, {'time': time.time() - start_time}

    def dijkstra_shortest_path(self, start: int, end: int):
        start_time = time.time()

        if start not in self.graph.adjacency_list or end not in self.graph.adjacency_list:
            return [], float('inf'), {'time': 0}

        distances = {node: float('inf') for node in self.graph.nodes}
        predecessors = {node: None for node in self.graph.nodes}
        distances[start] = 0

        priority_queue = [(0, start)]
        visited = set()

        while priority_queue:
            current_distance, current_node = heapq.heappop(priority_queue)

            if current_node in visited:
                continue

            visited.add(current_node)

            if current_node == end:
                break

            for neighbor, weight in self.graph.adjacency_list.get(current_node, []):
                if neighbor in visited:
                    continue

                new_distance = current_distance + weight
                if new_distance < distances[neighbor]:
                    distances[neighbor] = new_distance
                    predecessors[neighbor] = current_node
                    heapq.heappush(priority_queue, (new_distance, neighbor))

        path = []
        current = end
        while current is not None:
            path.append(current)
            current = predecessors[current]
        path.reverse()

        if not path or path[0] != start:
            return [], float('inf'), {'time': time.time() - start_time}

        return path, distances[end], {'time': time.time() - start_time}


class MapVisualizer:
    def __init__(self, center_lat: float = 47.8864, center_lon: float = 106.9057):
        self.map = folium.Map(
            location=[center_lat, center_lon],
            zoom_start=12,
            tiles='OpenStreetMap'
        )

    def add_path(self, coordinates: list, color: str = 'blue', weight: int = 5,
                 opacity: float = 0.7, popup: str = None):
        if len(coordinates) < 2:
            return

        folium.PolyLine(
            coordinates,
            color=color,
            weight=weight,  # Ð—Ð£Ð—ÐÐÐ - Ð¸Ð»Ò¯Ò¯ Ñ‚Ð¾Ð¼ Ñ‚Ð¾Ð¾ Ð¾Ñ€ÑƒÑƒÐ»Ð°Ñ…
            opacity=opacity,  # Ð¢ÐžÐ” Ð‘ÐÐ™Ð”ÐÐ› - 1.0 Ñ…Ò¯Ñ€Ñ‚ÑÐ»
            popup=popup
        ).add_to(self.map)

    def add_marker(self, lat: float, lon: float, color: str = 'red', popup: str = None):
        folium.Marker(
            [lat, lon],
            popup=popup,
            icon=folium.Icon(color=color)
        ).add_to(self.map)

    def show_map(self, filename: str = 'map.html'):
        self.map.save(filename)
        print(f"Ð“Ð°Ð·Ñ€Ñ‹Ð½ Ð·ÑƒÑ€Ð°Ð³ {filename} Ñ„Ð°Ð¹Ð»Ð´ Ñ…Ð°Ð´Ð³Ð°Ð»Ð°Ð³Ð´Ð»Ð°Ð°")
        webbrowser.open(f'file://{os.path.abspath(filename)}')

    def visualize_all_paths_clear(self, results: dict, graph):
        """Ð‘Ò¯Ñ… Ð·Ð°Ð¼ÑƒÑƒÐ´Ñ‹Ð³ Ñ‚Ð¾Ð´Ð¾Ñ€Ñ…Ð¾Ð¹ Ó©Ð½Ð³Ó©, Ð·ÑƒÐ·Ð°Ð°Ð½Ð°Ð°Ñ€ Ñ…Ð°Ñ€ÑƒÑƒÐ»Ð°Ñ…"""

        # Ó¨ÐÐ“Ó¨, Ð—Ð£Ð—ÐÐÐÐ« Ð¢ÐžÐ¥Ð˜Ð Ð“ÐžÐž
        path_styles = {
            'Dijkstra': {'color': '#FF0000', 'weight': 10, 'opacity': 1.0},  # Ð£Ð›ÐÐÐ, ÐœÐÐ¨ Ð—Ð£Ð—ÐÐÐ
            'BFS': {'color': '#0000FF', 'weight': 8, 'opacity': 0.9},  # Ð¦Ð­ÐÐ¥Ð­Ð , Ð—Ð£Ð—ÐÐÐ
            'DFS_shortest': {'color': '#FF00FF', 'weight': 6, 'opacity': 0.8},  # Ð¯Ð“ÐÐÐ, Ð”Ð£ÐÐ” Ð—Ð£Ð—ÐÐÐ
            'DFS_other': {'color': '#00FF00', 'weight': 4, 'opacity': 0.6}  # ÐÐžÐ“ÐžÐžÐ, ÐÐ˜ÐœÐ“Ð­Ð
        }

        # Dijkstra - Ð¥ÐÐœÐ“Ð˜Ð™Ð Ð—Ð£Ð—ÐÐÐ (10)
        if 'Dijkstra' in results and results['Dijkstra']['path']:
            path = results['Dijkstra']['path']
            coordinates = [graph.nodes[node_id] for node_id in path if node_id in graph.nodes]
            style = path_styles['Dijkstra']
            self.add_path(
                coordinates,
                color=style['color'],
                weight=style['weight'],
                opacity=style['opacity'],
                popup=f"ðŸš€ Dijkstra: {results['Dijkstra']['distance']:.0f}m"
            )

        # BFS - Ð—Ð£Ð—ÐÐÐ (8)
        if 'BFS' in results and results['BFS']['path']:
            path = results['BFS']['path']
            coordinates = [graph.nodes[node_id] for node_id in path if node_id in graph.nodes]
            style = path_styles['BFS']
            self.add_path(
                coordinates,
                color=style['color'],
                weight=style['weight'],
                opacity=style['opacity'],
                popup=f"ðŸ‘£ BFS: {results['BFS']['distance']:.0f}m, {results['BFS']['steps']} Ð°Ð»Ñ…Ð°Ð¼"
            )

        # DFS Ð·Ð°Ð¼ÑƒÑƒÐ´
        if 'DFS' in results and 'paths' in results['DFS']:
            for i, path_data in enumerate(results['DFS']['paths']):
                path = path_data['path']
                coordinates = [graph.nodes[node_id] for node_id in path if node_id in graph.nodes]

                if i == 0:  # Ð¥Ð°Ð¼Ð³Ð¸Ð¹Ð½ Ð±Ð¾Ð³Ð¸Ð½Ð¾ DFS Ð·Ð°Ð¼
                    style = path_styles['DFS_shortest']
                    popup_text = f"ðŸ† DFS: {path_data['distance']:.0f}m"
                else:  # Ð‘ÑƒÑÐ°Ð´ DFS Ð·Ð°Ð¼ÑƒÑƒÐ´
                    style = path_styles['DFS_other']
                    popup_text = f"ðŸŸ¢ DFS {i + 1}: {path_data['distance']:.0f}m"

                self.add_path(
                    coordinates,
                    color=style['color'],
                    weight=style['weight'],
                    opacity=style['opacity'],
                    popup=popup_text
                )

        # Ð­Ñ…Ð»ÑÐ», Ñ‚Ó©Ð³ÑÐ³Ó©Ð»Ð¸Ð¹Ð½ Ñ†ÑÐ³Ò¯Ò¯Ð´
        if results:
            for algo, result in results.items():
                if 'path' in result and result['path']:
                    start_node = result['path'][0]
                    end_node = result['path'][-1]
                    start_coord = graph.nodes.get(start_node)
                    end_coord = graph.nodes.get(end_node)

                    if start_coord:
                        self.add_marker(start_coord[0], start_coord[1], 'green', 'ðŸŽ¯ Ð­Ñ…Ð»ÑÑ…')
                    if end_coord:
                        self.add_marker(end_coord[0], end_coord[1], 'red', 'ðŸ Ð¢Ó©Ð³ÑÐ³Ó©Ð»')
                    break


def test_system():
    """Ð¥ÑÐ»Ð±Ð°Ñ€ÑˆÑƒÑƒÐ»ÑÐ°Ð½ Ñ‚ÑƒÑ€ÑˆÐ¸Ð»Ñ‚Ñ‹Ð½ ÑÐ¸ÑÑ‚ÐµÐ¼"""
    graph = GraphBuilder()

    # Ð¢ÑƒÑ€ÑˆÐ¸Ð»Ñ‚Ñ‹Ð½ Ó©Ð³Ó©Ð³Ð´Ó©Ð»
    test_nodes = {
        0: (47.918, 106.917), 1: (47.920, 106.920), 2: (47.925, 106.925), 3: (47.915, 106.930),
        4: (47.910, 106.920), 5: (47.905, 106.915), 6: (47.900, 106.910), 7: (47.895, 106.905),
    }

    test_edges = [
        (0, 1, 500), (1, 2, 800), (2, 3, 600), (0, 4, 700), (4, 5, 400), (5, 3, 300),
        (1, 4, 300), (2, 5, 500), (5, 6, 350), (6, 7, 450), (3, 7, 550), (0, 2, 1200)
    ]

    graph.nodes = test_nodes
    for node1, node2, weight in test_edges:
        graph.add_edge(node1, node2, weight)
        graph.add_edge(node2, node1, weight)

    search = SearchAlgorithms(graph)

    print("Ð—Ð°Ð¼Ñ‹Ð½ Ñ‚Ð¾Ð¾Ñ†Ð¾Ð¾Ð»Ð¾Ð» Ñ…Ð¸Ð¹Ð¶ Ð±Ð°Ð¹Ð½Ð°...")

    # Ð‘Ò¯Ñ… Ð°Ð»Ð³Ð¾Ñ€Ð¸Ñ‚Ð¼Ð°Ð°Ñ€ Ñ‚Ð¾Ð¾Ñ†Ð¾Ð¾Ð»Ð¾Ñ…
    results = {}

    # Dijkstra
    path, distance, metrics = search.dijkstra_shortest_path(0, 7)
    results['Dijkstra'] = {
        'path': path,
        'distance': distance,
        'steps': len(path) - 1 if path else 0
    }
    print(f"âœ“ Dijkstra: {distance:.1f}m")

    # BFS
    path, distance, metrics = search.bfs_shortest_path(0, 7)
    results['BFS'] = {
        'path': path,
        'distance': distance,
        'steps': len(path) - 1 if path else 0
    }
    print(f"âœ“ BFS: {distance:.1f}m")

    # DFS
    paths, metrics = search.dfs_all_paths(0, 7, 3)
    results['DFS'] = {
        'paths': paths
    }
    print(f"âœ“ DFS: {len(paths)} Ð·Ð°Ð¼ Ð¾Ð»Ð´ÑÐ¾Ð½")

    # Ò®Ñ€ Ð´Ò¯Ð½Ð³ Ñ…ÑÐ²Ð»ÑÑ…
    print("\n=== Ò®Ð  Ð”Ò®Ð ===")
    for algo, result in results.items():
        if algo == 'DFS':
            print(f"DFS - {len(result['paths'])} Ð·Ð°Ð¼:")
            for i, path_data in enumerate(result['paths']):
                print(f"  {i + 1}. {path_data['distance']:.1f}m")
        else:
            print(f"{algo}: {result['distance']:.1f}m")

    # Ð“Ð°Ð·Ñ€Ñ‹Ð½ Ð·ÑƒÑ€Ð°Ð³ Ò¯Ò¯ÑÐ³ÑÑ…
    print("\nÐ“Ð°Ð·Ñ€Ñ‹Ð½ Ð·ÑƒÑ€Ð°Ð³ Ò¯Ò¯ÑÐ³ÑÐ¶ Ð±Ð°Ð¹Ð½Ð°...")
    visualizer = MapVisualizer()
    visualizer.visualize_all_paths_clear(results, graph)
    visualizer.show_map('clear_paths.html')

    print("\nâœ… Ð‘ÐžÐ›Ð›ÐžÐž! ÐžÐ´Ð¾Ð¾ Ð·Ð°Ð¼ÑƒÑƒÐ´:")
    print("   ðŸš€ Dijkstra: Ð£Ð›ÐÐÐ, ÐœÐÐ¨ Ð—Ð£Ð—ÐÐÐ (10)")
    print("   ðŸ‘£ BFS: Ð¦Ð­ÐÐ¥Ð­Ð , Ð—Ð£Ð—ÐÐÐ (8)")
    print("   ðŸ† DFS Ñ…Ð°Ð¼Ð³Ð¸Ð¹Ð½ Ð±Ð¾Ð³Ð¸Ð½Ð¾: Ð¯Ð“ÐÐÐ, Ð”Ð£ÐÐ” (6)")
    print("   ðŸŸ¢ DFS Ð±ÑƒÑÐ°Ð´: ÐÐžÐ“ÐžÐžÐ, ÐÐ˜ÐœÐ“Ð­Ð (4)")


if __name__ == "__main__":
    test_system()